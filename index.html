<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>⚽ Generatore Tornei (v3.0)</title>
  
  <!-- PWA / Home Screen Icons -->
  <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>⚽</text></svg>">
  <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>⚽</text></svg>">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Torneo ⚽">
  <meta name="theme-color" content="#667eea">
  
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; padding: 20px; }
    .container { max-width: 1000px; margin: 0 auto; background: #fff; border-radius: 15px; box-shadow: 0 10px 40px rgba(0,0,0,0.2); padding: 30px; min-width: 0; }
    h1 { color: #667eea; text-align: center; margin-bottom: 30px; font-size: 2.2em; }
    h2 { color: #764ba2; margin-top: 30px; margin-bottom: 15px; border-bottom: 2px solid #667eea; padding-bottom: 10px; }
    .section { margin-bottom: 30px; }
    .input-group { display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap; }
    input[type="text"] { flex: 1 1 260px; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 16px; transition: border-color 0.3s; min-width: 0; }
    input[type="text"]:focus { outline: none; border-color: #667eea; }
    button { padding: 10px 16px; background: #667eea; color: #fff; border: none; border-radius: 8px; cursor: pointer; font-size: 15px; font-weight: 600; transition: all 0.3s; }
    button:hover { background: #764ba2; transform: translateY(-2px); box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4); }
    button:active { transform: translateY(0); }
    button.sm { padding: 6px 10px; font-size: 14px; }
    button.ghost { background: #f1f3f5; color: #333; }
    button.ghost:hover { background: #e9ecef; transform: none; box-shadow: none; }
    button.danger { background: #e74c3c; }
    button.success { background: #27ae60; }
    .players-list { display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px; margin-top: 15px; }
    .player-item { display: flex; justify-content: space-between; align-items: center; padding: 10px 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #667eea; }
    .player-item button { padding: 5px 10px; font-size: 14px; }
    .tournament-selection { display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 10px; margin-top: 15px; }
    .player-checkbox { display: flex; align-items: center; padding: 10px; background: #f8f9fa; border-radius: 8px; cursor: pointer; transition: all 0.3s; }
    .player-checkbox:hover { background: #e9ecef; }
    .player-checkbox input { margin-right: 10px; width: 18px; height: 18px; cursor: pointer; }
    .match-card { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: #fff; padding: 16px; border-radius: 12px; margin-bottom: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); min-width: 0; cursor: pointer; transition: transform 0.2s; }
    .match-card:hover { transform: scale(1.02); }
    .match-header { font-size: 1.05em; font-weight: bold; margin-bottom: 10px; text-align: center; display:flex; justify-content:space-between; gap:8px; align-items:center; }
    .teams { display: flex; justify-content: space-around; align-items: center; margin-bottom: 8px; gap: 10px; flex-wrap: wrap; }
    .team { text-align: center; flex: 1; min-width: 0; }
    .team-name { font-weight: bold; font-size: 1.05em; word-break: break-word; overflow-wrap: anywhere; }
    .vs { font-size: 1.4em; font-weight: bold; margin: 0 12px; }
    .match-info { text-align: center; font-size: 0.9em; margin-top: 6px; opacity: 0.9; }
    .alert { padding: 15px; background: #fff3cd; border-left: 4px solid #ffc107; border-radius: 8px; margin: 15px 0; color:#333; }
    .alert.info { background: #d1ecf1; border-left-color: #17a2b8; }
    .round-title { background: #764ba2; color: #fff; padding: 10px 16px; border-radius: 8px; margin: 16px 0 10px 0; font-size: 1.05em; font-weight: 700; }
    .pippo-note { background: #ffe5b4; padding: 8px; border-radius: 8px; margin-top: 8px; font-size: 0.9em; border-left: 4px solid #ff9800; color: #222; }
    .tournament-title { margin-top: 24px; background: #667eea; color: #fff; padding: 10px 16px; border-radius: 10px; font-weight: 700; display:flex; align-items:center; justify-content:space-between; }
    .grid-2 { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 16px; }
    .standings { margin:10px 0 16px; border:1px solid #e5e7eb; border-radius:10px; overflow:hidden; }
    .standings table { width:100%; border-collapse: collapse; }
    .standings th, .standings td { padding:8px 10px; border-bottom:1px solid #f1f3f5; text-align:left; }
    .standings th { background:#f8f9fa; font-weight:700; color:#444; }
    .badge { display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; font-weight:700; background:#f1f3f5; color:#333; }
    .badge.win { background:#d4edda; color:#1e7e34; }
    .badge.loss { background:#f8d7da; color:#721c24; }

    /* FULLSCREEN MATCH VIEW */
    .match-fullscreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh; /* fallback */
      height: 100dvh; /* dynamic viewport height per mobile */
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      z-index: 9999;
      display: none;
      flex-direction: column;
    }
    .match-fullscreen.active { display: flex; }
    
    .fs-header {
      padding: 15px;
      background: rgba(0,0,0,0.3);
      color: white;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 0.9em;
    }
    
    .fs-match-info {
      font-weight: bold;
      font-size: 1.1em;
    }
    
    .fs-close {
      background: rgba(255,255,255,0.2);
      border: 2px solid white;
      color: white;
      padding: 8px 16px;
      border-radius: 8px;
      font-size: 14px;
      cursor: pointer;
    }
    
    .fs-playing-area {
      flex: 1;
      display: flex;
      gap: 10px;
      padding: 10px;
    }
    
    .fs-team-box {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: rgba(255,255,255,0.95);
      border-radius: 20px;
      overflow: hidden;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 8px 30px rgba(0,0,0,0.3);
      position: relative;
    }
    
    .fs-team-box:active {
      transform: scale(0.98);
    }
    
    .fs-team-box.winner {
      background: linear-gradient(135deg, #d4edda 0%, #a8e6a1 100%);
      animation: winPulse 1s infinite;
    }
    
    @keyframes winPulse {
      0%, 100% { box-shadow: 0 8px 30px rgba(39, 174, 96, 0.4); }
      50% { box-shadow: 0 8px 40px rgba(39, 174, 96, 0.8); }
    }
    
    .fs-team-names {
      padding: 16px 20px;
      text-align: center;
      background: rgba(102, 126, 234, 0.1);
      border-bottom: 3px solid #667eea;
    }
    
    .fs-team-name {
      font-size: 1.3em;
      font-weight: bold;
      color: #333;
      line-height: 1.3;
    }
    
    .fs-score-area {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 8em;
      font-weight: bold;
      color: #667eea;
      user-select: none;
    }
    
    .fs-undo-btn {
      position: absolute;
      bottom: 15px;
      right: 15px;
      background: rgba(231, 76, 60, 0.8);
      color: white;
      border: none;
      border-radius: 50%;
      width: 45px;
      height: 45px;
      font-size: 20px;
      cursor: pointer;
      opacity: 0.6;
      transition: opacity 0.2s;
      z-index: 10;
    }
    
    .fs-undo-btn:hover {
      opacity: 1;
    }
    
    .fs-confirm-area {
      padding: 16px;
      background: rgba(0,0,0,0.3);
      display: flex;
      justify-content: center;
      gap: 15px;
    }
    
    .fs-confirm-btn {
      padding: 12px 40px;
      font-size: 1.2em;
      background: #27ae60;
      color: white;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      font-weight: bold;
      animation: confirmPulse 1.5s infinite;
    }
    
    @keyframes confirmPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    
    .fs-cancel-btn {
      padding: 12px 40px;
      font-size: 1.2em;
      background: rgba(255,255,255,0.2);
      color: white;
      border: 2px solid white;
      border-radius: 12px;
      cursor: pointer;
      font-weight: bold;
    }

    @media (max-width: 480px) {
      body { padding: 12px; }
      .container { padding: 16px; }
      .input-group { gap: 8px; }
      .players-list { grid-template-columns: 1fr; gap: 8px; }
      .tournament-selection { grid-template-columns: 1fr; gap: 8px; }
      .match-card { padding: 14px; }
      .teams { flex-direction: column; align-items: stretch; }
      .vs { margin: 6px 0; text-align: center; }
      .team { width: 100%; text-align: center; }
      
      .fs-score-area { font-size: 5em; }
      .fs-team-name { font-size: 1.1em; }
      .fs-undo-btn { width: 40px; height: 40px; font-size: 18px; }
    }
    
    @media (orientation: landscape) {
      .fs-score-area { font-size: 10em; }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>⚽ Generatore Tornei (v3.1)</h1>

    <div class="section">
      <h2>Seleziona Giocatori</h2>
      <div class="tournament-selection" id="tournamentSelection"></div>
      <div class="grid-2" style="margin-top: 12px;">
        <button id="btnGen" onclick="createSequentialTournaments(4)" title="Genera 4 tornei sequenziali con rotazioni">Genera 4 Tornei</button>
        <button class="success" onclick="createSequentialTournaments(1)" title="Genera un singolo torneo (con logica aggiornata)">Genera 1 Torneo</button>
      </div>
    </div>

    <div class="section" id="tournamentsSection" style="display:none;">
      <h2>Tornei Generati</h2>
      <div id="tournamentsContainer"></div>
    </div>

    <div class="section" id="playersSection">
      <h2>Inserisci Giocatori</h2>
      <div class="input-group">
        <input type="text" id="playerNameInput" placeholder="Nome giocatore" />
        <button onclick="addPlayer()">Aggiungi</button>
      </div>
      <div class="players-list" id="playersList"></div>
    </div>
  </div>

  <!-- FULLSCREEN MATCH VIEW -->
  <div class="match-fullscreen" id="matchFullscreen">
    <div class="fs-header">
      <div class="fs-match-info" id="fsMatchInfo">Torneo 1 - Partita 1</div>
      <button class="fs-close" onclick="closeFullscreenMatch()">Chiudi</button>
    </div>
    
    <div class="fs-playing-area">
      <div class="fs-team-box" id="fsTeam1" onclick="addGoal(1)">
        <div class="fs-team-names" id="fsTeam1Names">Squadra 1</div>
        <div class="fs-score-area" id="fsScore1">0</div>
        <button class="fs-undo-btn" onclick="event.stopPropagation(); removeGoal(1)">−</button>
      </div>
      
      <div class="fs-team-box" id="fsTeam2" onclick="addGoal(2)">
        <div class="fs-team-names" id="fsTeam2Names">Squadra 2</div>
        <div class="fs-score-area" id="fsScore2">0</div>
        <button class="fs-undo-btn" onclick="event.stopPropagation(); removeGoal(2)">−</button>
      </div>
    </div>
    
    <div class="fs-confirm-area" id="fsConfirmArea" style="display: none;">
      <button class="fs-confirm-btn" onclick="confirmMatch()">✓ Conferma e Prossima Partita</button>
      <button class="fs-cancel-btn" onclick="cancelWin()">✗ Annulla</button>
    </div>
  </div>

  <script>
    // ===== Data & State =====
    let players = ['Marco', 'Alessio', 'Alessandro', 'Andrea', 'Michele', 'Massimiliano', 'Enrico', 'Martin', 'Massimo', 'Karim', 'Vincenzo'];
    players.sort();
    let currentMatchState = { 
      ti: -1, 
      mi: -1, 
      score1: 0, 
      score2: 0, 
      goalsToWin: 5,
      bestOf3State: null // { gamesWon1: 0, gamesWon2: 0, currentGame: 1, swapSides: false }
    };

    function saveData() { localStorage.setItem('players', JSON.stringify(players)); }
    function loadData() { 
      const saved = localStorage.getItem('players');
      if (saved) {
        try {
          players = JSON.parse(saved);
        } catch (e) {
          console.error('Error loading data', e);
        }
      }
    }
    
    function shuffle(arr) { const a = arr.slice(); for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]]; } return a; }
    function teamKey(team) { return team.filter(p => p !== 'Pippo').join(' + '); }
    function pairKey(a, b) { const s = [a, b].sort(); return `${s[0]}|${s[1]}`; }

    // ===== Players =====
    function addPlayer() {
      const input = document.getElementById('playerNameInput');
      const name = input.value.trim();
      if (!name) { alert('Inserisci un nome!'); return; }
      if (players.includes(name)) { alert('Giocatore già presente!'); return; }
      players.push(name);
      saveData();
      renderPlayers();
      renderTournamentSelection();
      input.value = '';
    }

    function removePlayer(name) {
      if (!confirm(`Rimuovere ${name}?`)) return;
      players = players.filter(p => p !== name);
      saveData();
      renderPlayers();
      renderTournamentSelection();
    }

    function renderPlayers() {
      const container = document.getElementById('playersList');
      container.innerHTML = players.map(p => `<div class="player-item"><span>${p}</span><button class="danger sm" onclick="removePlayer('${p}')">Rimuovi</button></div>`).join('');
    }

    function renderTournamentSelection() {
      const container = document.getElementById('tournamentSelection');
      container.innerHTML = players.map(p => `<label class="player-checkbox"><input type="checkbox" class="player-select" value="${p}" />${p}</label>`).join('');
    }

    // ===== Pairing =====
    function bestPairing(base, historyPairs, tournamentIndex) {
      const candidates = [];
      for (let attempt = 0; attempt < 5000; attempt++) {
        const shuffled = shuffle(base);
        const pairs = [];
        for (let i = 0; i < shuffled.length; i += 2) {
          if (i + 1 < shuffled.length) pairs.push([shuffled[i], shuffled[i + 1]]);
          else pairs.push([shuffled[i]]);
        }
        const newPairs = pairs.filter(([a,b]) => b && !historyPairs.has(pairKey(a,b)));
        const score = newPairs.length * 1000 - pairs.filter(([a,b]) => b && historyPairs.has(pairKey(a,b))).length * 500;
        candidates.push({ pairs, score });
      }
      candidates.sort((a, b) => b.score - a.score);
      const best = candidates[0].pairs;
      const flipBias = (tournamentIndex % 2 === 1) ? 0.7 : 0.3;
      return best.map(team => (Math.random() < flipBias ? [team[1], team[0]] : team));
    }

    function buildMatches(teams) {
      const numTeams = teams.length;
      const goalsToWin = (numTeams === 2) ? 10 : 5;
      const matches = [];
      
      if (numTeams === 2) {
        matches.push({ round: 'Meglio dei 3', team1: teams[0], team2: teams[1], info: `Primo a vincere 2 partite su 3 (ogni partita a ${goalsToWin} goal)`, winner: 0, goalsToWin, gameResults: [], score1: 0, score2: 0 });
      }
      else if (numTeams === 3) {
        matches.push({ round: "Girone all'italiana", team1: teams[0], team2: teams[1], info: `Partita a ${goalsToWin} goal`, winner: 0, goalsToWin, score1: 0, score2: 0 });
        matches.push({ round: "Girone all'italiana", team1: teams[2], team2: teams[0], info: `Partita a ${goalsToWin} goal`, winner: 0, goalsToWin, score1: 0, score2: 0 });
        matches.push({ round: "Girone all'italiana", team1: teams[1], team2: teams[2], info: `Partita a ${goalsToWin} goal`, winner: 0, goalsToWin, score1: 0, score2: 0 });
      }
      else if (numTeams === 4) {
        matches.push({ round: 'Semifinale 1', team1: teams[0], team2: teams[1], info: `Partita a ${goalsToWin} goal`, winner: 0, goalsToWin, score1: 0, score2: 0 });
        matches.push({ round: 'Semifinale 2', team1: teams[2], team2: teams[3], info: `Partita a ${goalsToWin} goal`, winner: 0, goalsToWin, score1: 0, score2: 0 });
        matches.push({ round: 'Finale 3°/4° posto', team1: ['Perdente SF1'], team2: ['Perdente SF2'], info: `Partita a ${goalsToWin} goal`, winner: 0, goalsToWin, score1: 0, score2: 0 });
        matches.push({ round: 'FINALE 1°/2° posto', team1: ['Vincente SF1'], team2: ['Vincente SF2'], info: `Partita a ${goalsToWin} goal`, winner: 0, goalsToWin, score1: 0, score2: 0 });
      }
      else {
        // Per gironi con 5+ squadre, organizziamo i match in modo che chi rimane cambi lato
        // Usiamo un sistema round-robin con rotazione
        const orderedMatches = [];
        const teamsCopy = teams.slice();
        
        // Generiamo tutti i possibili match
        const allPairs = [];
        for (let i = 0; i < teamsCopy.length; i++) {
          for (let j = i + 1; j < teamsCopy.length; j++) {
            allPairs.push([teamsCopy[i], teamsCopy[j]]);
          }
        }
        
        // Riordiniamo i match per minimizzare le ripetizioni consecutive di squadre
        // e alternare i lati quando una squadra gioca consecutivamente
        const used = new Set();
        const lastSide = {}; // traccia su quale lato ha giocato l'ultima volta ogni squadra
        
        while (orderedMatches.length < allPairs.length) {
          let bestMatch = null;
          let bestScore = -1;
          
          for (const pair of allPairs) {
            const pairKey = `${teamKey(pair[0])}-${teamKey(pair[1])}`;
            if (used.has(pairKey)) continue;
            
            // Calcola score: preferisci match dove nessuna squadra ha appena giocato
            let score = 100;
            if (orderedMatches.length > 0) {
              const lastMatch = orderedMatches[orderedMatches.length - 1];
              const team0Key = teamKey(pair[0]);
              const team1Key = teamKey(pair[1]);
              const lastTeam1Key = teamKey(lastMatch.team1);
              const lastTeam2Key = teamKey(lastMatch.team2);
              
              // Se una squadra ha appena giocato, riduci lo score
              if (team0Key === lastTeam1Key || team0Key === lastTeam2Key) score -= 50;
              if (team1Key === lastTeam1Key || team1Key === lastTeam2Key) score -= 50;
              
              // Ma se una squadra DEVE giocare di nuovo, assicurati che cambi lato
              let finalTeam1 = pair[0];
              let finalTeam2 = pair[1];
              
              if (team0Key === lastTeam1Key || team0Key === lastTeam2Key) {
                // team0 ha appena giocato, dovrebbe cambiare lato
                if (lastSide[team0Key] === 'left') {
                  // Era a sinistra, ora deve stare a destra
                  finalTeam1 = pair[1];
                  finalTeam2 = pair[0];
                  score += 25; // bonus per cambio lato corretto
                }
              }
              
              if (team1Key === lastTeam1Key || team1Key === lastTeam2Key) {
                // team1 ha appena giocato, dovrebbe cambiare lato
                if (lastSide[team1Key] === 'right') {
                  // Era a destra, ora deve stare a sinistra
                  finalTeam1 = pair[1];
                  finalTeam2 = pair[0];
                  score += 25; // bonus per cambio lato corretto
                }
              }
            }
            
            if (score > bestScore) {
              bestScore = score;
              bestMatch = pair;
            }
          }
          
          if (bestMatch) {
            let team1 = bestMatch[0];
            let team2 = bestMatch[1];
            
            // Se una delle due squadre ha giocato nel match precedente, mettila dall'altro lato
            if (orderedMatches.length > 0) {
              const lastMatch = orderedMatches[orderedMatches.length - 1];
              const team1Key = teamKey(team1);
              const team2Key = teamKey(team2);
              const lastTeam1Key = teamKey(lastMatch.team1);
              const lastTeam2Key = teamKey(lastMatch.team2);
              
              // Se team1 era nel match precedente, controlla su quale lato e invertilo
              if (team1Key === lastTeam1Key && lastSide[team1Key] === 'left') {
                [team1, team2] = [team2, team1]; // sposta a destra
              } else if (team1Key === lastTeam2Key && lastSide[team1Key] === 'right') {
                // già a sinistra, va bene
              } else if (team2Key === lastTeam1Key && lastSide[team2Key] === 'left') {
                // team2 era a sinistra, ora deve stare a destra (già è a destra)
              } else if (team2Key === lastTeam2Key && lastSide[team2Key] === 'right') {
                [team1, team2] = [team2, team1]; // sposta a sinistra
              }
            }
            
            lastSide[teamKey(team1)] = 'left';
            lastSide[teamKey(team2)] = 'right';
            
            orderedMatches.push({ 
              round: 'Girone', 
              team1: team1, 
              team2: team2, 
              info: `Partita a ${goalsToWin} goal`, 
              winner: 0, 
              goalsToWin,
              score1: 0,
              score2: 0
            });
            
            const pairKey = `${teamKey(bestMatch[0])}-${teamKey(bestMatch[1])}`;
            used.add(pairKey);
          }
        }
        
        return orderedMatches;
      }
      return matches;
    }

    function createSequentialTournaments(n = 4) {
      const selected = Array.from(document.querySelectorAll('.player-select:checked')).map(cb => cb.value);
      if (selected.length < 4) { alert('Seleziona almeno 4 giocatori!'); return; }
      
      const isOdd = (selected.length % 2 !== 0);
      const base = isOdd ? selected.concat('Pippo') : selected.slice();

      const tournaments = [];
      const historyPairs = new Set();
      let lastPartner = null;
      
      for (let t = 0; t < n; t++) {
        let teams = bestPairing(base, historyPairs, t);
        let pippoPartner = null;
        
        if (isOdd) {
          let pippoIdx = teams.findIndex(team => team.includes('Pippo'));
          if (pippoIdx === -1) {
            if (teams.length === 0) teams.push(['Pippo']);
            else teams[0][0] = 'Pippo';
            pippoIdx = 0;
          }
          pippoPartner = teams[pippoIdx].find(p => p !== 'Pippo');
          
          if (lastPartner && pippoPartner === lastPartner) {
            let changed = false;
            for (let j = 0; j < teams.length && !changed; j++) {
              if (j === pippoIdx) continue;
              for (let m = 0; m < teams[j].length && !changed; m++) {
                const candidate = teams[j][m];
                if (candidate !== lastPartner) {
                  const ex = pippoPartner;
                  teams[j][m] = ex;
                  const k = teams[pippoIdx].indexOf(ex);
                  teams[pippoIdx][k] = candidate;
                  pippoPartner = candidate;
                  changed = true;
                }
              }
            }
          }
          lastPartner = pippoPartner;
        }
        
        for (const [a,b] of teams) historyPairs.add(pairKey(a,b));
        const matches = buildMatches(teams);
        matches.forEach(mm => mm.pippoSub = null);
        const pippoQueue = isOdd ? shuffle(selected.filter(p => p !== pippoPartner)) : [];
        const standings = initStandings(teams);
        tournaments.push({ teams, matches, hasPippo: isOdd, pippoPartner, standings, pippoQueue, _pippoQueueState: null });
      }
      
      window.__tournaments = tournaments;
      window.__selectedPlayers = selected;
      renderSequentialTournaments(tournaments);
      
      // Sposta la sezione "Inserisci Giocatori" in fondo
      const container = document.querySelector('.container');
      const playersSection = document.getElementById('playersSection');
      if (container && playersSection) {
        container.appendChild(playersSection);
      }
    }

    // ===== Standings =====
    function initStandings(teams) {
      const table = {};
      teams.forEach(team => {
        table[teamKey(team)] = { team: team.slice(), W: 0, L: 0, GF: 0, GS: 0, GD: 0 };
      });
      return table;
    }

    function resetTournament(ti) {
      const t = window.__tournaments[ti];
      t.matches.forEach(m => m.winner = 0);
      t.standings = initStandings(t.teams);
      renderSequentialTournaments(window.__tournaments);
    }

    function recordResult(ti, mi, winnerSide) {
      const t = window.__tournaments[ti];
      const m = t.matches[mi];
      if (!m) return;
      m.winner = winnerSide;
      
      t.standings = initStandings(t.teams);
      t.matches.forEach(mm => {
        if (mm.winner === 1 || mm.winner === 2) {
          const A = teamKey(mm.team1), B = teamKey(mm.team2);
          if (!(A in t.standings)) t.standings[A] = { team: mm.team1.slice(), W:0, L:0, GF:0, GS:0, GD:0 };
          if (!(B in t.standings)) t.standings[B] = { team: mm.team2.slice(), W:0, L:0, GF:0, GS:0, GD:0 };
          
          // Calcola vittorie e sconfitte
          if (mm.winner === 1) { 
            t.standings[A].W++; 
            t.standings[B].L++; 
          }
          if (mm.winner === 2) { 
            t.standings[B].W++; 
            t.standings[A].L++; 
          }
          
          // Calcola goal fatti e subiti (se disponibili)
          if (mm.score1 !== undefined && mm.score2 !== undefined) {
            t.standings[A].GF += mm.score1;
            t.standings[A].GS += mm.score2;
            t.standings[B].GF += mm.score2;
            t.standings[B].GS += mm.score1;
          }
          
          // Calcola differenza reti
          t.standings[A].GD = t.standings[A].GF - t.standings[A].GS;
          t.standings[B].GD = t.standings[B].GF - t.standings[B].GS;
        }
      });
      
      // Per tornei a 4 squadre, aggiorna i placeholder delle finali
      if (t.teams.length === 4) {
        updateSemifinalPlaceholders(t);
      }
      
      if (t.teams.length === 3) {
        if (mi === 0 && (m.winner === 1 || m.winner === 2)) {
          const loser = (m.winner === 1) ? teamKey(m.team2) : teamKey(m.team1);
          const involvesLoser = (mm) => teamKey(mm.team1) === loser || teamKey(mm.team2) === loser;
          if (!involvesLoser(t.matches[1]) && involvesLoser(t.matches[2])) {
            const tmp = t.matches[1];
            t.matches[1] = t.matches[2];
            t.matches[2] = tmp;
          }
        }
      }
      
      renderSequentialTournaments(window.__tournaments);
    }
    
    function updateSemifinalPlaceholders(t) {
      // Trova le semifinali
      const sf1 = t.matches.find(m => m.round === 'Semifinale 1');
      const sf2 = t.matches.find(m => m.round === 'Semifinale 2');
      
      // Trova le finali
      const final34 = t.matches.find(m => m.round === 'Finale 3°/4° posto');
      const final12 = t.matches.find(m => m.round === 'FINALE 1°/2° posto');
      
      // Se SF1 è completata, aggiorna i placeholder
      if (sf1 && sf1.winner !== 0) {
        const winner1 = sf1.winner === 1 ? sf1.team1 : sf1.team2;
        const loser1 = sf1.winner === 1 ? sf1.team2 : sf1.team1;
        
        // Aggiorna finale 1°/2° posto
        if (final12 && final12.team1[0] === 'Vincente SF1') {
          final12.team1 = winner1.slice();
        }
        if (final12 && final12.team2[0] === 'Vincente SF1') {
          final12.team2 = winner1.slice();
        }
        
        // Aggiorna finale 3°/4° posto
        if (final34 && final34.team1[0] === 'Perdente SF1') {
          final34.team1 = loser1.slice();
        }
        if (final34 && final34.team2[0] === 'Perdente SF1') {
          final34.team2 = loser1.slice();
        }
      }
      
      // Se SF2 è completata, aggiorna i placeholder
      if (sf2 && sf2.winner !== 0) {
        const winner2 = sf2.winner === 1 ? sf2.team1 : sf2.team2;
        const loser2 = sf2.winner === 1 ? sf2.team2 : sf2.team1;
        
        // Aggiorna finale 1°/2° posto
        if (final12 && final12.team1[0] === 'Vincente SF2') {
          final12.team1 = winner2.slice();
        }
        if (final12 && final12.team2[0] === 'Vincente SF2') {
          final12.team2 = winner2.slice();
        }
        
        // Aggiorna finale 3°/4° posto
        if (final34 && final34.team1[0] === 'Perdente SF2') {
          final34.team1 = loser2.slice();
        }
        if (final34 && final34.team2[0] === 'Perdente SF2') {
          final34.team2 = loser2.slice();
        }
      }
    }

    function getWinnersList(t) {
      if (t.matches.some(m => m.round.includes('FINALE'))) {
        const final = t.matches.find(m => m.round.includes('FINALE'));
        if (final && (final.winner === 1 || final.winner === 2)) {
          return [ final.winner === 1 ? teamKey(final.team1) : teamKey(final.team2) ];
        }
        return [];
      }
      
      // Ordina per: vittorie (desc), differenza reti (desc), sconfitte (asc)
      const arr = Object.values(t.standings).slice().sort((a,b) => 
        (b.W - a.W) || (b.GD - a.GD) || (a.L - b.L)
      );
      
      if (!arr.length) return [];
      
      // Controlla se tutti i match sono stati giocati
      const allMatchesPlayed = t.matches.every(m => m.winner !== 0);
      
      if (allMatchesPlayed) {
        // Se tutti i match sono stati giocati, restituisci solo il primo (considerando differenza reti)
        return [teamKey(arr[0].team)];
      } else {
        // Se i match non sono ancora tutti giocati, restituisci tutti con le stesse vittorie (comportamento precedente)
        const topW = arr[0].W;
        return arr.filter(x => x.W === topW).map(x => teamKey(x.team));
      }
    }

    // ===== Fullscreen Match =====
    function openFullscreenMatch(ti, mi) {
      const t = window.__tournaments[ti];
      const m = t.matches[mi];
      
      const isBestOf3 = m.round === 'Meglio dei 3';
      
      currentMatchState = {
        ti: ti,
        mi: mi,
        score1: 0,
        score2: 0,
        goalsToWin: m.goalsToWin || 5,
        bestOf3State: isBestOf3 ? { gamesWon1: 0, gamesWon2: 0, currentGame: 1, swapSides: false } : null
      };
      
      // Setup UI
      let team1 = m.team1.slice();
      let team2 = m.team2.slice();
      
      if (t.hasPippo && (team1.includes('Pippo') || team2.includes('Pippo'))) {
        let pippoSub = m.pippoSub || null;
        if (!pippoSub) {
          const playing = team1.concat(team2).filter(p => p !== 'Pippo');
          const q = t._pippoQueueState || [];
          let idx = q.findIndex(p => p !== t.pippoPartner && !playing.includes(p));
          if (idx === -1) idx = q.findIndex(p => p !== t.pippoPartner);
          if (idx >= 0) {
            pippoSub = q[idx];
            q.splice(idx,1);
            q.push(pippoSub);
            m.pippoSub = pippoSub;
          }
        }
        team1 = team1.map(p => p === 'Pippo' ? `Pippo (${pippoSub || '—'})` : p);
        team2 = team2.map(p => p === 'Pippo' ? `Pippo (${pippoSub || '—'})` : p);
      }
      
      updateFullscreenUI(ti, mi, team1, team2);
      
      document.getElementById('matchFullscreen').classList.add('active');
    }
    
    function updateFullscreenUI(ti, mi, team1, team2) {
      const t = window.__tournaments[ti];
      const m = t.matches[mi];
      const state = currentMatchState.bestOf3State;
      
      let matchInfo = `Torneo ${ti+1} - ${m.round} - Partita ${mi+1}`;
      if (state) {
        matchInfo = `Torneo ${ti+1} - ${m.round} - Game ${state.currentGame}/3 (${state.gamesWon1}-${state.gamesWon2})`;
      }
      
      // Swap teams if needed
      if (state && state.swapSides) {
        [team1, team2] = [team2, team1];
      }
      
      document.getElementById('fsMatchInfo').textContent = matchInfo;
      document.getElementById('fsTeam1Names').innerHTML = team1.join('<br>');
      document.getElementById('fsTeam2Names').innerHTML = team2.join('<br>');
      document.getElementById('fsScore1').textContent = '0';
      document.getElementById('fsScore2').textContent = '0';
      document.getElementById('fsConfirmArea').style.display = 'none';
      document.getElementById('fsTeam1').classList.remove('winner');
      document.getElementById('fsTeam2').classList.remove('winner');
    }

    function closeFullscreenMatch() {
      document.getElementById('matchFullscreen').classList.remove('active');
      currentMatchState = { ti: -1, mi: -1, score1: 0, score2: 0, goalsToWin: 5, bestOf3State: null };
    }

    function addGoal(team) {
      const { goalsToWin } = currentMatchState;
      
      if (team === 1) {
        // Blocca se ha già raggiunto il massimo
        if (currentMatchState.score1 >= goalsToWin) {
          return;
        }
        currentMatchState.score1++;
        document.getElementById('fsScore1').textContent = currentMatchState.score1;
      } else {
        // Blocca se ha già raggiunto il massimo
        if (currentMatchState.score2 >= goalsToWin) {
          return;
        }
        currentMatchState.score2++;
        document.getElementById('fsScore2').textContent = currentMatchState.score2;
      }
      
      checkWinner();
    }

    function removeGoal(team) {
      if (team === 1 && currentMatchState.score1 > 0) {
        currentMatchState.score1--;
        document.getElementById('fsScore1').textContent = currentMatchState.score1;
      } else if (team === 2 && currentMatchState.score2 > 0) {
        currentMatchState.score2--;
        document.getElementById('fsScore2').textContent = currentMatchState.score2;
      }
      
      checkWinner();
    }

    function checkWinner() {
      const { score1, score2, goalsToWin } = currentMatchState;
      
      if (score1 >= goalsToWin || score2 >= goalsToWin) {
        document.getElementById('fsConfirmArea').style.display = 'flex';
        if (score1 >= goalsToWin) {
          document.getElementById('fsTeam1').classList.add('winner');
          document.getElementById('fsTeam2').classList.remove('winner');
        } else {
          document.getElementById('fsTeam2').classList.add('winner');
          document.getElementById('fsTeam1').classList.remove('winner');
        }
      } else {
        document.getElementById('fsConfirmArea').style.display = 'none';
        document.getElementById('fsTeam1').classList.remove('winner');
        document.getElementById('fsTeam2').classList.remove('winner');
      }
    }

    function cancelWin() {
      document.getElementById('fsConfirmArea').style.display = 'none';
      document.getElementById('fsTeam1').classList.remove('winner');
      document.getElementById('fsTeam2').classList.remove('winner');
    }

    function confirmMatch() {
      const { ti, mi, score1, score2, goalsToWin, bestOf3State } = currentMatchState;
      
      if (score1 < goalsToWin && score2 < goalsToWin) {
        alert('Nessuna squadra ha raggiunto i goal necessari!');
        return;
      }
      
      const t = window.__tournaments[ti];
      const m = t.matches[mi];
      
      // Determina chi ha vinto questo game (considerando swap sides)
      let gameWinner1 = score1 >= goalsToWin;
      if (bestOf3State && bestOf3State.swapSides) {
        gameWinner1 = !gameWinner1; // Se i lati sono swappati, inverti il vincitore
      }
      
      // Se è "Meglio dei 3", gestisci la logica delle partite multiple
      if (bestOf3State) {
        // Salva il risultato di questo game
        if (!m.gameResults) m.gameResults = [];
        m.gameResults.push({
          game: bestOf3State.currentGame,
          score1: gameWinner1 ? (score1 >= goalsToWin ? score1 : score2) : (score1 >= goalsToWin ? score2 : score1),
          score2: gameWinner1 ? (score1 >= goalsToWin ? score2 : score1) : (score1 >= goalsToWin ? score1 : score2),
          winner: gameWinner1 ? 1 : 2
        });
        
        if (gameWinner1) {
          bestOf3State.gamesWon1++;
        } else {
          bestOf3State.gamesWon2++;
        }
        
        // Controlla se qualcuno ha vinto il match (2 partite su 3)
        if (bestOf3State.gamesWon1 >= 2 || bestOf3State.gamesWon2 >= 2) {
          // Fine del "Meglio dei 3" - determina il vincitore finale
          const finalWinner = bestOf3State.gamesWon1 >= 2 ? 1 : 2;
          
          // Calcola i punteggi totali sommando tutti i game
          let totalScore1 = 0, totalScore2 = 0;
          m.gameResults.forEach(gr => {
            totalScore1 += gr.score1;
            totalScore2 += gr.score2;
          });
          m.score1 = totalScore1;
          m.score2 = totalScore2;
          
          recordResult(ti, mi, finalWinner);
          
          // Mostra schermata di vittoria
          showBestOf3Victory(ti, mi, finalWinner);
        } else {
          // Continua con il prossimo game, cambiando campo
          bestOf3State.currentGame++;
          bestOf3State.swapSides = !bestOf3State.swapSides;
          
          // Reset punteggi per il prossimo game
          currentMatchState.score1 = 0;
          currentMatchState.score2 = 0;
          
          // Recupera i nomi delle squadre originali
          let team1 = m.team1.slice();
          let team2 = m.team2.slice();
          
          if (t.hasPippo && (team1.includes('Pippo') || team2.includes('Pippo'))) {
            let pippoSub = m.pippoSub;
            team1 = team1.map(p => p === 'Pippo' ? `Pippo (${pippoSub || '—'})` : p);
            team2 = team2.map(p => p === 'Pippo' ? `Pippo (${pippoSub || '—'})` : p);
          }
          
          // Aggiorna UI per il prossimo game
          updateFullscreenUI(ti, mi, team1, team2);
        }
      } else {
        // Match normale (non "Meglio dei 3")
        const winner = score1 >= goalsToWin ? 1 : 2;
        
        // Salva i punteggi nel match
        m.score1 = score1;
        m.score2 = score2;
        
        recordResult(ti, mi, winner);
        
        // Check if there's a next match
        const nextMatchIndex = mi + 1;
        
        // Controlla se questo era l'ultimo match del torneo
        if (nextMatchIndex >= t.matches.length) {
          // Era l'ultimo match - mostra schermata vincitore per tornei con 3+ squadre
          if (t.teams.length >= 3) {
            const winners = getWinnersList(t);
            if (winners.length > 0) {
              showTournamentVictory(ti, winners[0]);
              return; // Non chiudere subito
            }
          }
        }
        
        closeFullscreenMatch();
        
        if (nextMatchIndex < t.matches.length) {
          // Auto-open next match after a short delay
          setTimeout(() => {
            openFullscreenMatch(ti, nextMatchIndex);
          }, 500);
        }
      }
    }
    
    function showTournamentVictory(ti, winnerName) {
      // Nascondi i quadrati di gioco e mostra messaggio di vittoria
      document.querySelector('.fs-playing-area').style.display = 'none';
      document.getElementById('fsConfirmArea').style.display = 'none';
      
      const victoryMessage = document.createElement('div');
      victoryMessage.id = 'victoryMessage';
      victoryMessage.style.cssText = `
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 40px;
        text-align: center;
      `;
      victoryMessage.innerHTML = `
        <div style="font-size: 3em; margin-bottom: 20px;">🏆</div>
        <div style="font-size: 2em; font-weight: bold; color: white; margin-bottom: 30px;">
          Vincitori del Torneo!
        </div>
        <div style="font-size: 1.8em; font-weight: bold; color: #ffd700; margin-bottom: 40px;">
          ${winnerName}
        </div>
        <button class="fs-confirm-btn" onclick="closeTournamentVictory()">
          ✓ Chiudi e Torna ai Tornei
        </button>
      `;
      
      document.getElementById('matchFullscreen').appendChild(victoryMessage);
    }
    
    function closeTournamentVictory() {
      const victoryMessage = document.getElementById('victoryMessage');
      if (victoryMessage) {
        victoryMessage.remove();
      }
      document.querySelector('.fs-playing-area').style.display = 'flex';
      closeFullscreenMatch();
    }
    
    function showBestOf3Victory(ti, mi, winner) {
      const t = window.__tournaments[ti];
      const m = t.matches[mi];
      const winnerTeam = winner === 1 ? m.team1 : m.team2;
      const winnerName = teamKey(winnerTeam);
      
      // Nascondi i quadrati di gioco e mostra messaggio di vittoria
      document.querySelector('.fs-playing-area').style.display = 'none';
      document.getElementById('fsConfirmArea').style.display = 'none';
      
      const victoryMessage = document.createElement('div');
      victoryMessage.id = 'victoryMessage';
      victoryMessage.style.cssText = `
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 40px;
        text-align: center;
      `;
      victoryMessage.innerHTML = `
        <div style="font-size: 3em; margin-bottom: 20px;">🏆</div>
        <div style="font-size: 2em; font-weight: bold; color: white; margin-bottom: 30px;">
          Vincitori del Torneo!
        </div>
        <div style="font-size: 1.8em; font-weight: bold; color: #ffd700; margin-bottom: 40px;">
          ${winnerName}
        </div>
        <button class="fs-confirm-btn" onclick="closeBestOf3Victory(${ti}, ${mi})">
          ✓ Chiudi e Torna ai Tornei
        </button>
      `;
      
      document.getElementById('matchFullscreen').appendChild(victoryMessage);
    }
    
    function closeBestOf3Victory(ti, mi) {
      const victoryMessage = document.getElementById('victoryMessage');
      if (victoryMessage) {
        victoryMessage.remove();
      }
      document.querySelector('.fs-playing-area').style.display = 'flex';
      closeFullscreenMatch();
      
      // Check if there's a next match in other tournaments
      const t = window.__tournaments[ti];
      const nextMatchIndex = mi + 1;
      
      if (nextMatchIndex < t.matches.length) {
        setTimeout(() => {
          openFullscreenMatch(ti, nextMatchIndex);
        }, 500);
      }
    }

    // ===== Render =====
    function renderSequentialTournaments(tournaments) {
      const section = document.getElementById('tournamentsSection');
      const container = document.getElementById('tournamentsContainer');
      container.innerHTML = '';
      
      tournaments.forEach((t, ti) => {
        if (t.hasPippo && !t._pippoQueueState) {
          t._pippoQueueState = t.pippoQueue ? t.pippoQueue.slice() : [];
        }
        
        const winners = getWinnersList(t);
        let headerRight = `<div style="display:flex; gap:8px; align-items:center;">${winners.length ? `<span class=\"badge\">Vincitore: ${winners.join(', ')}</span>` : ''}<button class=\"ghost sm\" onclick=\"resetTournament(${ti})\">Reset ris.​</button></div>`;
        let html = `<div class="tournament-title">🏆 Torneo ${ti+1} ${headerRight}</div>`;
        
        if (t.hasPippo) {
          html += `<div class="alert info"><strong>⚠️ Numero dispari di giocatori!</strong><br>È presente il giocatore virtuale <strong>Pippo</strong>.<br>Il <strong>partner di Pippo varia</strong> torneo per torneo (qui: <strong>${t.pippoPartner || '—'}</strong>).<br>La sostituzione di Pippo ruota tra gli altri giocatori nei vari match e tornei, e resta fissa una volta assegnata.</div>`;
        }
        
        const standingsRows = Object.values(t.standings)
          .sort((a,b) => (b.W - a.W) || (b.GD - a.GD) || (a.L - b.L) || teamKey(a.team).localeCompare(teamKey(b.team)))
          .map((row, idx) => {
            const isWinner = idx === 0 && t.matches.every(m => m.winner !== 0) && (t.teams.length >= 3);
            const rowClass = isWinner ? ' style="background: #d4edda; font-weight: bold;"' : '';
            return `<tr${rowClass}><td>${isWinner ? '🏆 ' : ''}${teamKey(row.team)}</td><td><span class=\"badge win\">${row.W}</span></td><td><span class=\"badge loss\">${row.L}</span></td><td>${row.GF}</td><td>${row.GS}</td><td style="font-weight: bold;">${row.GD > 0 ? '+' : ''}${row.GD}</td></tr>`;
          })
          .join('');
        html += `<div class="standings"><table><thead><tr><th>Coppia</th><th>V</th><th>P</th><th>GF</th><th>GS</th><th>DR</th></tr></thead><tbody>${standingsRows}</tbody></table></div>`;
        
        let currentRound = '';
        let partHtml = '';
        
        t.matches.forEach((match, mi) => {
          if (match.round !== currentRound) {
            if (currentRound !== '') partHtml += '</div>';
            partHtml += `<div class="round-title">${match.round}</div><div>`;
            currentRound = match.round;
          }
          
          let team1 = match.team1.slice();
          let team2 = match.team2.slice();
          
          if (t.hasPippo && (team1.includes('Pippo') || team2.includes('Pippo'))) {
            let pippoSub = match.pippoSub || null;
            if (!pippoSub) {
              const playing = team1.concat(team2).filter(p => p !== 'Pippo');
              const q = t._pippoQueueState || [];
              let idx = q.findIndex(p => p !== t.pippoPartner && !playing.includes(p));
              if (idx === -1) idx = q.findIndex(p => p !== t.pippoPartner);
              if (idx >= 0) {
                pippoSub = q[idx];
                q.splice(idx,1);
                q.push(pippoSub);
                match.pippoSub = pippoSub;
              }
            }
            team1 = team1.map(p => p === 'Pippo' ? `Pippo (${pippoSub || '—'})` : p);
            team2 = team2.map(p => p === 'Pippo' ? `Pippo (${pippoSub || '—'})` : p);
          }
          
          const status = match.winner === 1 ? `✅ Vince: ${teamKey(match.team1)}` : match.winner === 2 ? `✅ Vince: ${teamKey(match.team2)}` : 'Da giocare';
          
          // Aggiungi i risultati dei singoli game se è "Meglio dei 3"
          let gameResultsHtml = '';
          if (match.round === 'Meglio dei 3' && match.gameResults && match.gameResults.length > 0) {
            gameResultsHtml = '<div style="margin-top: 10px; padding: 10px; background: rgba(255,255,255,0.2); border-radius: 8px;">';
            gameResultsHtml += '<div style="font-weight: bold; margin-bottom: 5px; font-size: 0.9em;">Risultati singoli game:</div>';
            match.gameResults.forEach(gr => {
              const winnerText = gr.winner === 1 ? teamKey(match.team1) : teamKey(match.team2);
              gameResultsHtml += `<div style="font-size: 0.85em; margin: 3px 0;">Game ${gr.game}: ${gr.score1}-${gr.score2} (Vince: ${winnerText})</div>`;
            });
            gameResultsHtml += '</div>';
          }
          
          partHtml += `<div class="match-card" onclick="openFullscreenMatch(${ti}, ${mi})">
            <div class="match-header">
              <span>Partita ${mi + 1}</span>
              <span class="badge">${status}</span>
            </div>
            <div class="teams">
              <div class="team">
                <div class="team-name">${team1.join('<br>')}</div>
              </div>
              <div class="vs">VS</div>
              <div class="team">
                <div class="team-name">${team2.join('<br>')}</div>
              </div>
            </div>
            <div class="match-info">${match.info}</div>
            ${gameResultsHtml}
            ${match.pippoSub ? `<div class=\"pippo-note\">🔄 In questa partita Pippo è sostituito da <strong>${match.pippoSub}</strong></div>` : ''}
            <div style="margin-top: 10px; text-align: center; font-size: 0.9em; opacity: 0.8;">
              👆 Tap per aprire schermata di gioco
            </div>
          </div>`;
        });
        
        partHtml += '</div>';
        html += partHtml;
        container.insertAdjacentHTML('beforeend', html);
      });
      
      section.style.display = 'block';
    }

    // ===== Init =====
    loadData();
    renderPlayers();
    renderTournamentSelection();
  </script>
</body>
</html>
